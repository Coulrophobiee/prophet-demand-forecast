<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prophet Food Demand Forecasting with Business Cost Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px;
        }
        .container {
            max-width: 1400px; margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px; padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        .header {
            text-align: center; margin-bottom: 40px;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .header h1 { font-size: 3rem; font-weight: 700; margin-bottom: 10px; }
        .header p { font-size: 1.2rem; color: #666; margin-bottom: 30px; }
        .status {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white; padding: 20px; border-radius: 15px; margin-bottom: 30px;
        }
        .controls {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 20px; margin-bottom: 30px; padding: 25px;
            background: rgba(255, 255, 255, 0.7); border-radius: 15px;
        }
        .control-group { display: flex; flex-direction: column; width: 100%; }
        .control-group label { font-weight: 600; margin-bottom: 8px; color: #333; }
        .control-group input, .control-group select {
            padding: 12px; border: 2px solid #e0e0e0; border-radius: 10px;
            font-size: 14px; transition: all 0.3s ease; width: 100%; box-sizing: border-box;
        }
        .control-group input:focus, .control-group select:focus {
            outline: none; border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .action-buttons {
            display: flex; gap: 15px; justify-content: center;
            grid-column: 1 / -1; margin-top: 15px;
        }
        .btn {
            padding: 18px 40px; background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white; border: none; border-radius: 12px; font-size: 18px;
            font-weight: 600; cursor: pointer; transition: all 0.3s ease;
            text-transform: uppercase; letter-spacing: 1px; min-width: 200px;
        }
        .btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 12px 25px rgba(78, 205, 196, 0.4); 
        }
        .btn.secondary {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
        }
        .btn.secondary:hover {
            box-shadow: 0 12px 25px rgba(255, 107, 107, 0.4);
        }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .metrics {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px; margin-bottom: 30px;
        }
        .metric-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white; padding: 25px; border-radius: 15px; text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3); transition: transform 0.3s ease;
        }
        .metric-card:hover { transform: translateY(-5px); }
        .metric-card h3 { font-size: 2.5rem; margin-bottom: 10px; font-weight: 700; }
        .metric-card p { font-size: 1.1rem; opacity: 0.9; }
        
        /* Financial Impact Analysis Styles */
        .business-cost-section {
            background: linear-gradient(135deg, #FF6B6B, #4ECDC4);
            color: white; padding: 25px; border-radius: 15px; margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(255, 107, 107, 0.3);
        }
        .cost-comparison-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px; margin: 20px 0;
        }
        .cost-card {
            background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 12px;
            backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .cost-card.savings { 
            border: 2px solid rgba(76, 175, 80, 0.7);
            background: rgba(76, 175, 80, 0.2);
        }
        .cost-card.cost-loss { 
            border: 2px solid rgba(244, 67, 54, 0.7);
            background: rgba(244, 67, 54, 0.2);
        }
        .cost-card.prophet { border: 2px solid rgba(102, 126, 234, 0.5); }
        .cost-card.baseline { border: 2px solid rgba(255, 255, 255, 0.3); }
        .cost-value { font-size: 2rem; font-weight: bold; margin-bottom: 5px; }
        .cost-label { font-size: 1rem; opacity: 0.9; }
        .cost-description { font-size: 0.85rem; margin-top: 8px; opacity: 0.8; }
        
        /* Weekly Financial Impact Styles */
        .weekly-cost-section {
            background: linear-gradient(135deg, #4ECDC4, #44A08D);
            color: white; padding: 25px; border-radius: 15px; margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.3);
        }
        .weekly-cost-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px; margin: 20px 0;
        }
        .weekly-cost-item {
            text-align: center; padding: 20px;
            background: rgba(255, 255, 255, 0.1); border-radius: 12px;
            backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .weekly-cost-item.savings { 
            border: 2px solid rgba(76, 175, 80, 0.7);
            background: rgba(76, 175, 80, 0.2);
        }
        .weekly-cost-item.cost-loss { 
            border: 2px solid rgba(244, 67, 54, 0.7);
            background: rgba(244, 67, 54, 0.2);
        }
        .weekly-cost-value { font-size: 2rem; font-weight: bold; margin-bottom: 5px; }
        .weekly-cost-label { font-size: 1rem; opacity: 0.9; }
        .weekly-cost-description { font-size: 0.85rem; margin-top: 8px; opacity: 0.8; }
        
        .charts {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 30px; margin-bottom: 30px;
        }
        .chart-container {
            background: white; padding: 25px; border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            min-height: 400px;
        }
        .chart-container h3 {
            text-align: center; margin-bottom: 20px;
            color: #333; font-size: 1.3rem;
        }
        .chart-container canvas {
            max-height: 350px;
        }
        .full-width { grid-column: 1 / -1; }
        
        .performance-section {
            background: white; padding: 25px; border-radius: 15px;
            margin-bottom: 30px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        .performance-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px; margin-top: 20px;
        }
        .performance-item {
            text-align: center; padding: 15px;
            background: #f8f9fa; border-radius: 10px;
        }
        .performance-item .value { font-size: 1.5rem; font-weight: bold; color: #667eea; }
        .performance-item .label { font-size: 0.9rem; color: #666; margin-top: 5px; }
        
        .comparison-section {
            background: linear-gradient(135deg, #FF6B6B, #FF8E53);
            color: white; padding: 25px; border-radius: 15px;
            margin-bottom: 30px; box-shadow: 0 10px 30px rgba(255, 107, 107, 0.3);
        }
        .comparison-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px; margin-top: 20px;
        }
        .comparison-item {
            text-align: center; padding: 20px;
            background: rgba(255, 255, 255, 0.1); border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        .comparison-item .value { font-size: 2rem; font-weight: bold; margin-bottom: 5px; }
        .comparison-item .label { font-size: 1rem; opacity: 0.9; }
        .comparison-item.prophet { border: 2px solid rgba(102, 126, 234, 0.5); }
        .comparison-item.baseline { border: 2px solid rgba(255, 255, 255, 0.3); }
        .comparison-item.improvement { 
            border: 2px solid rgba(76, 175, 80, 0.7);
            background: rgba(76, 175, 80, 0.2);
        }
        
        .insights {
            background: linear-gradient(135deg, #FF6B6B, #4ECDC4);
            color: white; padding: 25px; border-radius: 15px; margin-top: 30px;
        }
        .insights h3 { margin-bottom: 15px; font-size: 1.5rem; }
        .insights ul { list-style: none; padding-left: 0; }
        .insights li {
            margin-bottom: 10px; padding-left: 20px; position: relative;
        }
        .insights li:before {
            content: "✓"; position: absolute; left: 0; font-weight: bold;
        }
        
        .loading { display: none; text-align: center; padding: 20px; }
        .spinner {
            border: 4px solid #f3f3f3; border-top: 4px solid #667eea;
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 2s linear infinite; margin: 0 auto 10px;
        }
        .error-message {
            background: #ffe6e6; color: #d63384; padding: 15px;
            border-radius: 10px; margin: 10px 0; border-left: 4px solid #d63384;
        }
        .selection-preserved {
            border-color: #28a745 !important;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.1) !important;
        }
        
        .business-summary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white; padding: 25px; border-radius: 15px; margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }
        .business-summary h3 {
            margin-bottom: 20px; font-size: 1.5rem; text-align: center;
        }
        .business-grid-single {
            display: flex;
            justify-content: center;
            margin-bottom: 25px;
        }
        .business-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px; margin-bottom: 25px;
        }
        .business-week-card, .business-total-card {
            background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 12px;
            backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .business-single-week-card {
            background: rgba(255, 255, 255, 0.15); padding: 30px; border-radius: 15px;
            backdrop-filter: blur(10px); border: 2px solid rgba(255, 255, 255, 0.3);
            max-width: 400px; margin: 0 auto; text-align: center;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        .business-total-card {
            border: 2px solid rgba(255, 215, 0, 0.5); background: rgba(255, 215, 0, 0.1);
        }
        .business-week-card h4, .business-total-card h4 {
            margin-bottom: 15px; font-size: 1.2rem; text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3); padding-bottom: 8px;
        }
        .forecast-value {
            font-size: 2.2rem; font-weight: bold; text-align: center; margin-bottom: 8px;
        }
        .forecast-value.total {
            font-size: 2.5rem; color: #ffd700;
        }
        .forecast-label {
            text-align: center; font-size: 1rem; margin-bottom: 15px; opacity: 0.9;
        }
        .confidence-range {
            text-align: center; font-size: 0.9rem; margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.1); padding: 8px; border-radius: 6px;
        }
        .business-actions {
            border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 12px;
        }
        .action-item {
            margin-bottom: 8px; font-size: 0.9rem; padding: 4px 0;
        }
        .business-recommendations {
            background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .business-recommendations h4 {
            margin-bottom: 15px; font-size: 1.2rem;
        }
        .business-recommendations ul {
            list-style: none; padding-left: 0;
        }
        .business-recommendations li {
            margin-bottom: 12px; padding-left: 20px; position: relative;
            background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;
        }
        .business-recommendations li:before {
            content: "💡"; position: absolute; left: -5px; font-size: 1.1rem;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @media (max-width: 768px) {
            .charts { grid-template-columns: 1fr; }
            .header h1 { font-size: 2rem; }
            .controls { grid-template-columns: 1fr; }
            .cost-comparison-grid { grid-template-columns: 1fr; }
            .weekly-cost-grid { grid-template-columns: 1fr; }
        }
        @media (max-width: 1024px) and (min-width: 769px) {
            .controls { grid-template-columns: 1fr 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🧠 Prophet Food Demand Forecasting</h1>
            <p>AI-Powered Regional Analysis with Financial Impact Assessment</p>
        </div>

        <div class="status" id="statusSection">
            <h3>📊 System Status</h3>
            <p id="statusMessage">Loading data and initializing Prophet models...</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="mealSelect">Meal (Required):</label>
                <select id="mealSelect"><option value="">Select a specific meal...</option></select>
                <small id="mealInfo" style="color: #666; font-size: 0.8rem; margin-top: 4px;"></small>
            </div>
            <div class="control-group">
                <label for="regionSelect">Region (Optional):</label>
                <select id="regionSelect"><option value="">All Regions</option></select>
                <small id="regionInfo" style="color: #666; font-size: 0.8rem; margin-top: 4px;"></small>
            </div>
            <div class="control-group">
                <label for="forecastWeeks">Forecast Weeks:</label>
                <input type="number" id="forecastWeeks" value="10" min="1" max="52">
            </div>
            <div class="control-group">
                <label for="confidence">Confidence Level (%):</label>
                <input type="number" id="confidence" value="95" min="50" max="99" step="1" placeholder="e.g. 95">
            </div>
            <div class="action-buttons">
                <button class="btn" onclick="trainAndShowForecast()" id="mainActionBtn">Train & Show Forecast + Financial Impact</button>
            </div>
        </div>

        <div class="loading" id="loadingSection">
            <div class="spinner"></div>
            <p>Training Prophet model, generating forecast, and calculating financial impact...</p>
        </div>

        <!-- Financial Impact Analysis Section -->
        <div class="business-cost-section" id="businessCostSection" style="display: none;">
            <h3>💰 Financial Impact: Prophet vs Baseline</h3>
            <p>Money saved (or lost) by using Prophet instead of naive "same week last year" forecasting</p>
            <div class="cost-comparison-grid" id="costComparisonGrid"></div>
        </div>

        <!-- Weekly Financial Impact Section -->
        <div class="weekly-cost-section" id="weeklyCostSection" style="display: none;">
            <h3>📅 Weekly Financial Impact</h3>
            <p>Average weekly savings (or losses) from using Prophet instead of baseline forecasting</p>
            <div class="weekly-cost-grid" id="weeklyCostGrid"></div>
        </div>

        <div class="performance-section" id="performanceSection" style="display: none;">
            <h3>🎯 Model Performance Evaluation</h3>
            <p>Performance metrics using train data split evaluation:</p>
            <div class="performance-grid" id="performanceGrid"></div>
        </div>

        <div class="comparison-section" id="comparisonSection" style="display: none;">
            <h3>🥊 Prophet vs Baseline Model Comparison</h3>
            <p>Comparing Prophet against a naive "same week last year" baseline model:</p>
            <div class="comparison-grid" id="comparisonGrid"></div>
        </div>

        <div class="metrics" id="metricsContainer" style="display: none;">
            <div class="metric-card">
                <h3 id="modelAccuracy">-</h3>
                <p>Prophet Accuracy</p>
            </div>
            <div class="metric-card">
                <h3 id="avgDemand">-</h3>
                <p>Avg Predicted Demand</p>
            </div>
            <div class="metric-card">
                <h3 id="totalForecast">-</h3>
                <p>Total Forecast</p>
            </div>
            <div class="metric-card">
                <h3 id="confidenceLevel">95%</h3>
                <p>Confidence Level</p>
            </div>
        </div>

        <div class="charts">
            <div class="chart-container full-width">
                <h3>📈 Prophet Regional Demand Forecast</h3>
                <canvas id="forecastChart"></canvas>
            </div>
            <div class="chart-container">
                <h3>📊 Model Performance Radar</h3>
                <canvas id="performanceChart"></canvas>
            </div>
            <div class="chart-container">
                <h3 id="trainingPerformanceTitle">🎯 Prophet vs Baseline Comparison</h3>
                <canvas id="accuracyChart"></canvas>
            </div>
        </div>

        <div class="insights" id="insights" style="display: none;">
            <h3>🧠 Prophet Model Insights & Business Recommendations</h3>
            <ul id="insightsList"></ul>
        </div>
    </div>

    <script>
        let currentModel = null, currentForecast = null, currentMetrics = null;
        let currentTrainingPerformance = null, currentComparison = null;
        let currentBusinessCost = null;
        let dataAvailability = null;
        let forecastChart = null, performanceChart = null, accuracyChart = null;
        
        // User selection preservation
        let userSelections = {
            meal: '',
            region: '',
            forecastWeeks: 10,
            confidence: 95
        };
        let isInitialLoad = true;

        // Store user selections whenever they change
        function storeUserSelections() {
            userSelections.meal = document.getElementById('mealSelect').value;
            userSelections.region = document.getElementById('regionSelect').value;
            userSelections.forecastWeeks = document.getElementById('forecastWeeks').value;
            userSelections.confidence = document.getElementById('confidence').value;
        }

        // Restore user selections after dropdown population
        function restoreUserSelections() {
            if (isInitialLoad) {
                isInitialLoad = false;
                return;
            }

            const mealSelect = document.getElementById('mealSelect');
            const regionSelect = document.getElementById('regionSelect');
            const forecastWeeks = document.getElementById('forecastWeeks');
            const confidence = document.getElementById('confidence');
            
            // Restore selections if options exist
            if (userSelections.meal && Array.from(mealSelect.options).some(opt => opt.value === userSelections.meal)) {
                mealSelect.value = userSelections.meal;
                mealSelect.classList.add('selection-preserved');
                setTimeout(() => mealSelect.classList.remove('selection-preserved'), 2000);
            }
            
            if (userSelections.region && Array.from(regionSelect.options).some(opt => opt.value === userSelections.region)) {
                regionSelect.value = userSelections.region;
                regionSelect.classList.add('selection-preserved');
                setTimeout(() => regionSelect.classList.remove('selection-preserved'), 2000);
            }
            
            forecastWeeks.value = userSelections.forecastWeeks;
            confidence.value = userSelections.confidence;
            
            // Update selection info after restoration
            updateSelectionInfo();
        }

        function showError(message, error = null) {
            // Clean up the message first
            const cleanMessage = formatErrorMessage(message);
            const cleanError = error ? formatErrorMessage(error) : null;
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.innerHTML = `<strong>Error:</strong> ${cleanMessage}`;
            if (cleanError) {
                errorDiv.innerHTML += `<br><small>${cleanError}</small>`;
            }
            
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.controls'));
            
            // Remove error after 10 seconds
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 10000);
        }

        document.addEventListener('DOMContentLoaded', function() {
            loadSystemStatus();
            
            // Add event listeners for selection preservation
            document.getElementById('regionSelect').addEventListener('change', function() {
                storeUserSelections();
                updateSelectionInfo();
            });
            
            document.getElementById('mealSelect').addEventListener('change', function() {
                storeUserSelections();
                updateSelectionInfo();
            });
            
            document.getElementById('forecastWeeks').addEventListener('change', storeUserSelections);
            document.getElementById('confidence').addEventListener('change', storeUserSelections);
        });

        async function loadSystemStatus() {
            try {
                const response = await fetch('/api/summary');
                const data = await response.json();
                
                updateStatusSection(data);
                populateSelectors(data);
                
                await loadDataAvailability();
            } catch (error) {
                document.getElementById('statusMessage').textContent = 
                    '❌ Error: Could not load data. Make sure train.csv and test.csv are in the same directory.';
                showError('Could not connect to backend server. Make sure the Python server is running.', error.message);
            }
        }

        async function loadDataAvailability() {
            try {
                const response = await fetch('/api/data_availability');
                const data = await response.json();
                
                if (data.success) {
                    dataAvailability = data.availability;
                    updateSelectionInfo();
                } else {
                    console.warn('Could not load data availability');
                }
            } catch (error) {
                console.error('Error loading data availability:', error);
            }
        }

        function updateSelectionInfo() {
            if (!dataAvailability) return;
            
            const region = document.getElementById('regionSelect').value;
            const meal = document.getElementById('mealSelect').value;
            
            let currentKey;
            if (region && meal) {
                currentKey = `meal_${meal}_${region}`;
            } else if (meal) {
                currentKey = `meal_${meal}`;
            } else {
                currentKey = 'overall';
            }
            
            const regionInfo = document.getElementById('regionInfo');
            const mealInfo = document.getElementById('mealInfo');
            
            if (dataAvailability[currentKey]) {
                const info = dataAvailability[currentKey];
                const status = info.sufficient ? '✅' : '❌';
                const infoText = `${status} ${info.weeks} weeks, avg: ${Math.round(info.avg_demand).toLocaleString()}`;
                
                if (region) {
                    regionInfo.textContent = infoText;
                    regionInfo.style.color = info.sufficient ? '#059669' : '#dc2626';
                } else {
                    regionInfo.textContent = '';
                }
                
                if (meal) {
                    mealInfo.textContent = infoText;
                    mealInfo.style.color = info.sufficient ? '#059669' : '#dc2626';
                } else {
                    mealInfo.textContent = '';
                }
                
                const trainBtn = document.getElementById('mainActionBtn');
                if (info.sufficient) {
                    trainBtn.style.opacity = '1';
                    trainBtn.title = `Ready to train with ${info.weeks} weeks of data`;
                } else {
                    trainBtn.style.opacity = '0.7';
                    trainBtn.title = `Insufficient data: only ${info.weeks} weeks (need 30+)`;
                }
            }
        }

        function updateStatusSection(data) {
            const statusMsg = document.getElementById('statusMessage');
            if (data.data_info.train_records > 0) {
                const businessCostStatus = data.data_info.business_cost_analysis_enabled ? 
                    '<br>💰 Business cost analysis: Enabled with AI-generated meal database' : 
                    '<br>⚠️ Business cost analysis: Limited (no meal database)';
                
                statusMsg.innerHTML = `✅ Data loaded successfully<br>📊 Training data: ${data.data_info.train_records.toLocaleString()} records<br>🧪 Test data: ${data.data_info.test_records.toLocaleString()} records<br>🗺️ Regions: 4 | 🍽️ Meals: ${data.data_info.meals.length}<br>📅 Weeks: ${data.data_info.weeks_range[0]} - ${data.data_info.weeks_range[1]}${businessCostStatus}`;
            } else {
                statusMsg.textContent = '❌ No data found. Please ensure train.csv and test.csv are in the same directory.';
            }
        }

        function populateSelectors(data) {
            const regionSelect = document.getElementById('regionSelect');
            const mealSelect = document.getElementById('mealSelect');
            
            regionSelect.innerHTML = '<option value="">All Regions</option>';
            mealSelect.innerHTML = '<option value="">Select a specific meal...</option>';
            
            // Use actual regions from data instead of hardcoded ones
            if (data.data_info.regions && data.data_info.regions.length > 0) {
                data.data_info.regions.forEach(region => {
                    const option = document.createElement('option');
                    option.value = region; 
                    option.textContent = region;
                    regionSelect.appendChild(option);
                });
            } else {
                // Fallback to default regions
                ['Region_1', 'Region_2', 'Region_3', 'Region_4'].forEach(region => {
                    const option = document.createElement('option');
                    option.value = region; 
                    option.textContent = region;
                    regionSelect.appendChild(option);
                });
            }
            
            // Use meal names if available, otherwise fall back to IDs
            if (data.data_info.meals_with_names && data.data_info.meals_with_names.length > 0) {
                // Sort meals by name for better user experience
                const sortedMeals = data.data_info.meals_with_names.sort((a, b) => {
                    return a.name.localeCompare(b.name);
                });
                
                sortedMeals.forEach(meal => {
                    const option = document.createElement('option');
                    option.value = meal.id;
                    option.textContent = `${meal.name} (ID: ${meal.id})`;
                    option.title = meal.name; // Show full name on hover
                    mealSelect.appendChild(option);
                });
            } else {
                // Fallback to meal IDs only
                data.data_info.meals.forEach(meal => {
                    const option = document.createElement('option');
                    option.value = meal; 
                    option.textContent = `Meal ${meal}`;
                    mealSelect.appendChild(option);
                });
            }
            
            // Restore user selections after populating
            restoreUserSelections();
        }

        // Main action - train model and generate forecast with baseline comparison
        async function trainAndShowForecast() {
            const region = document.getElementById('regionSelect').value;
            const meal = document.getElementById('mealSelect').value;
            
            if (!meal) {
                alert('Please select a meal first!');
                return;
            }
            
            showLoading(true); 
            disableButtons(true);
            
            try {
                // Step 1: Train the model
                let url = '/api/train';
                const params = new URLSearchParams();
                if (region) params.append('region', region);
                if (meal) params.append('meal', meal);
                if (params.toString()) url += '?' + params.toString();
                
                const trainResponse = await fetch(url);
                const trainData = await trainResponse.json();
                
                if (!trainData.success) {
                    const cleanMessage = formatErrorMessage(trainData.message || 'Training failed');
                    showStatusMessage('❌ ' + cleanMessage, 'error');
                    showError('Training failed', cleanMessage);
                    return;
                }
                
                currentModel = trainData.model_key || `${region || 'all'}_${meal || 'all'}`;
                if (currentModel === 'all_all') currentModel = 'overall';
                currentMetrics = trainData.metrics;
                
                await loadTrainingPerformance(currentModel);
                
                if (trainData.metrics) {
                    showPerformanceSection(trainData.metrics);
                }
                
                // Step 2: Generate forecast
                const weeks = document.getElementById('forecastWeeks').value;
                const confidence = document.getElementById('confidence').value;
                
                const forecastResponse = await fetch(`/api/forecast?model=${encodeURIComponent(currentModel)}&weeks=${weeks}&confidence=${confidence}`);
                const forecastData = await forecastResponse.json();
                
                if (!forecastData.success) {
                    const cleanMessage = formatErrorMessage(forecastData.message || 'Forecast generation failed');
                    showStatusMessage('❌ ' + cleanMessage, 'error');
                    showError('Forecast generation failed', cleanMessage);
                    return;
                }
                
                currentForecast = forecastData.forecast; 
                if (currentMetrics && currentMetrics.meal_id) {
                    currentForecast.meal_id = currentMetrics.meal_id;
                }
                
                // Step 3: Generate baseline comparison
                const comparisonResponse = await fetch(`/api/model_comparison?model=${encodeURIComponent(currentModel)}`);
                const comparisonData = await comparisonResponse.json();
                
                if (comparisonData.success) {
                    currentComparison = comparisonData.comparison;
                    showComparisonSection(comparisonData.comparison);
                }
                
                // Step 4: Handle automatic business cost analysis from forecast response
                console.log("🔍 Checking for business cost analysis in forecast response:", forecastData);
                if (forecastData.business_cost_analysis) {
                    console.log("✅ Business cost analysis found:", forecastData.business_cost_analysis);
                    currentBusinessCost = forecastData.business_cost_analysis;
                    showBusinessCostAnalysis(forecastData.business_cost_analysis);
                    console.log("✅ Business cost analysis displayed");
                } else {
                    console.log("❌ No business cost analysis in forecast response");
                    console.log("🔍 Forecast response keys:", Object.keys(forecastData));
                }
                
                // Update dashboard
                updateDashboard();
                
                const comparisonText = currentComparison ? 
                    ` | Prophet: ${currentComparison.prophet_metrics.accuracy.toFixed(1)}% vs Baseline: ${currentComparison.baseline_metrics.accuracy.toFixed(1)}%` : '';
                
                const costText = currentBusinessCost ? 
                    (currentBusinessCost.avg_weekly_savings_euro >= 0 ? 
                        ` | Saving €${currentBusinessCost.avg_weekly_savings_euro.toFixed(2)}/week` : 
                        ` | Losing €${Math.abs(currentBusinessCost.avg_weekly_savings_euro).toFixed(2)}/week`) : '';
                
                console.log("📊 Status message will include:", { comparisonText, costText });
                showStatusMessage(`✅ Complete! Prophet model trained, forecast generated, and financial impact calculated${comparisonText}${costText}`, 'success');
                
            } catch (error) {
                console.error('Error in train and forecast:', error);
                const cleanMessage = formatErrorMessage(error.message);
                showStatusMessage('❌ Error: ' + cleanMessage, 'error');
                showError('Training and forecast failed', cleanMessage);
            }
            
            showLoading(false); 
            disableButtons(false);
        }

        function showBusinessCostAnalysis(businessData) {
            // Show business cost section
            const costSection = document.getElementById('businessCostSection');
            const costGrid = document.getElementById('costComparisonGrid');
            costGrid.innerHTML = '';
            
            // Update title with meal information
            const title = costSection.querySelector('h3');
            const mealName = businessData.meal_name || `Meal ${businessData.meal_id}`;
            title.textContent = `💰 Financial Impact: Prophet vs Baseline for ${mealName}`;
            
            // Update description to focus on savings
            const description = costSection.querySelector('p');
            description.textContent = 'Money saved (or lost) by using Prophet instead of naive "same week last year" forecasting';
            
            const isSaving = businessData.cost_savings_euro >= 0;
            const savingsSign = isSaving ? '+' : '';
            const impactIcon = isSaving ? '💰' : '❌';
            const impactLabel = isSaving ? 'Money Saved' : 'Additional Cost';
            const impactDescription = isSaving ? 
                `Saved by avoiding baseline's poor predictions` : 
                `Lost due to Prophet being worse than baseline`;
            
            // Main financial impact
            const impactCard = document.createElement('div');
            impactCard.className = isSaving ? 'cost-card savings' : 'cost-card cost-loss';
            impactCard.innerHTML = `
                <div class="cost-value">${impactIcon} ${savingsSign}€${Math.abs(businessData.cost_savings_euro).toFixed(2)}</div>
                <div class="cost-label">${impactLabel}</div>
                <div class="cost-description">${impactDescription} over ${businessData.weeks_analyzed} test weeks</div>
            `;
            costGrid.appendChild(impactCard);
            
            // Percentage improvement
            const percentCard = document.createElement('div');
            percentCard.className = 'cost-card';
            const percentSign = businessData.cost_savings_percentage >= 0 ? '+' : '';
            const percentIcon = businessData.cost_savings_percentage >= 0 ? '📈' : '📉';
            percentCard.innerHTML = `
                <div class="cost-value">${percentIcon} ${percentSign}${businessData.cost_savings_percentage.toFixed(1)}%</div>
                <div class="cost-label">Cost Improvement</div>
                <div class="cost-description">Compared to baseline approach</div>
            `;
            costGrid.appendChild(percentCard);
            
            // Decision recommendation
            const recommendCard = document.createElement('div');
            recommendCard.className = isSaving ? 'cost-card prophet' : 'cost-card baseline';
            const recommendation = isSaving ? 'Use Prophet' : 'Reconsider Prophet';
            const recommendIcon = isSaving ? '✅' : '⚠️';
            const recommendDesc = isSaving ? 
                'Prophet clearly outperforms baseline' : 
                'Baseline performs better - review model';
            recommendCard.innerHTML = `
                <div class="cost-value">${recommendIcon} ${recommendation}</div>
                <div class="cost-label">Recommendation</div>
                <div class="cost-description">${recommendDesc}</div>
            `;
            costGrid.appendChild(recommendCard);
            
            costSection.style.display = 'block';
            
            // Show weekly cost analysis
            showWeeklyCostAnalysis(businessData);
        }

        function showWeeklyCostAnalysis(businessData) {
            const weeklySection = document.getElementById('weeklyCostSection');
            const weeklyGrid = document.getElementById('weeklyCostGrid');
            weeklyGrid.innerHTML = '';
            
            // Update title and description to focus on savings
            const title = weeklySection.querySelector('h3');
            title.textContent = '📅 Weekly Financial Impact';
            
            const description = weeklySection.querySelector('p');
            description.textContent = 'Average weekly savings (or losses) from using Prophet instead of baseline forecasting';
            
            const isSaving = businessData.avg_weekly_savings_euro >= 0;
            const savingsSign = isSaving ? '+' : '';
            const savingsIcon = isSaving ? '💰' : '💸';
            
            // Weekly impact (main metric)
            const weeklyImpactItem = document.createElement('div');
            weeklyImpactItem.className = isSaving ? 'weekly-cost-item savings' : 'weekly-cost-item cost-loss';
            weeklyImpactItem.innerHTML = `
                <div class="weekly-cost-value">${savingsIcon} ${savingsSign}€${Math.abs(businessData.avg_weekly_savings_euro).toFixed(2)}</div>
                <div class="weekly-cost-label">${isSaving ? 'Weekly Savings' : 'Weekly Loss'}</div>
                <div class="weekly-cost-description">${isSaving ? 'Money saved each week with Prophet' : 'Money lost each week vs baseline'}</div>
            `;
            weeklyGrid.appendChild(weeklyImpactItem);
            
            // Annual projection
            const annualImpact = businessData.annual_savings_estimate_euro;
            const annualIsSaving = annualImpact >= 0;
            const annualSign = annualIsSaving ? '+' : '';
            const annualIcon = annualIsSaving ? '📈' : '📉';
            
            const annualItem = document.createElement('div');
            annualItem.className = annualIsSaving ? 'weekly-cost-item' : 'weekly-cost-item cost-loss';
            annualItem.innerHTML = `
                <div class="weekly-cost-value">${annualIcon} ${annualSign}€${Math.abs(annualImpact).toLocaleString()}</div>
                <div class="weekly-cost-label">${annualIsSaving ? 'Annual Savings' : 'Annual Loss'}</div>
                <div class="weekly-cost-description">Projected yearly impact (52 weeks)</div>
            `;
            weeklyGrid.appendChild(annualItem);
            
            // Test period context
            const testPeriodItem = document.createElement('div');
            testPeriodItem.className = 'weekly-cost-item';
            testPeriodItem.innerHTML = `
                <div class="weekly-cost-value">📊 ${businessData.weeks_analyzed}</div>
                <div class="weekly-cost-label">Test Weeks</div>
                <div class="weekly-cost-description">Real historical comparison period</div>
            `;
            weeklyGrid.appendChild(testPeriodItem);
            
            // Business insight
            const insightItem = document.createElement('div');
            insightItem.className = 'weekly-cost-item';
            const insightText = isSaving ? 
                (businessData.avg_weekly_savings_euro > 50 ? 'Significant Impact' : 'Moderate Impact') :
                'Needs Review';
            const insightIcon = isSaving ? 
                (businessData.avg_weekly_savings_euro > 50 ? '🎯' : '👍') : '⚠️';
            const insightDesc = isSaving ?
                (businessData.avg_weekly_savings_euro > 50 ? 'High value from Prophet forecasting' : 'Positive but modest improvement') :
                'Consider model improvements';
                
            insightItem.innerHTML = `
                <div class="weekly-cost-value">${insightIcon} ${insightText}</div>
                <div class="weekly-cost-label">Business Impact</div>
                <div class="weekly-cost-description">${insightDesc}</div>
            `;
            weeklyGrid.appendChild(insightItem);
            
            weeklySection.style.display = 'block';
        }

        async function loadTrainingPerformance(modelKey) {
            try {
                const response = await fetch(`/api/training_performance?model=${encodeURIComponent(modelKey)}`);
                const data = await response.json();
                
                if (data.success) {
                    currentTrainingPerformance = data.performance;
                } else {
                    currentTrainingPerformance = null;
                }
            } catch (error) {
                console.error('Error loading training performance:', error);
                currentTrainingPerformance = null;
            }
        }

        function showPerformanceSection(metrics) {
            if (!metrics) return;
            
            const section = document.getElementById('performanceSection');
            const grid = document.getElementById('performanceGrid');
            grid.innerHTML = '';
            
            const title = section.querySelector('h3');
            if (metrics.meal_id) {
                const mealName = metrics.meal_name || `Meal ${metrics.meal_id}`;
                title.textContent = `🎯 Model Performance Evaluation - ${mealName}${metrics.region_id ? ` (${metrics.region_id})` : ''}`;
            }
            
            const metricsConfig = [
                { key: 'accuracy', label: 'Accuracy', format: val => val != null ? val.toFixed(1) + '%' : 'N/A' },
                { key: 'mae', label: 'MAE', format: val => val != null ? val.toFixed(0) : 'N/A' },
                { key: 'rmse', label: 'RMSE', format: val => val != null ? val.toFixed(0) : 'N/A' },
                { key: 'r2', label: 'R² Score', format: val => val != null ? val.toFixed(3) : 'N/A' },
                { key: 'mape', label: 'MAPE', format: val => val != null ? val.toFixed(1) + '%' : 'N/A' },
                { key: 'total_weeks_used', label: 'Training Weeks', format: val => val != null ? val.toString() : 'N/A' }
            ];
            
            metricsConfig.forEach(config => {
                const item = document.createElement('div');
                item.className = 'performance-item';
                const value = metrics[config.key];
                item.innerHTML = `<div class="value">${config.format(value)}</div><div class="label">${config.label}</div>`;
                grid.appendChild(item);
            });
            
            if (metrics.evaluation_weeks) {
                const evalItem = document.createElement('div');
                evalItem.className = 'performance-item';
                evalItem.innerHTML = `<div class="value">${metrics.evaluation_weeks}</div><div class="label">Evaluation Period</div>`;
                grid.appendChild(evalItem);
            }
            
            section.style.display = 'block';
        }

        function showComparisonSection(comparison) {
            if (!comparison) return;
            
            const section = document.getElementById('comparisonSection');
            const grid = document.getElementById('comparisonGrid');
            grid.innerHTML = '';
            
            const title = section.querySelector('h3');
            const mealId = comparison.meal_id || 'Unknown';
            const regionText = comparison.region_id ? ` (${comparison.region_id})` : ' (All Regions)';
            title.textContent = `🥊 Prophet vs Baseline Comparison - Meal ${mealId}${regionText}`;
            
            // Prophet metrics
            const prophetItem = document.createElement('div');
            prophetItem.className = 'comparison-item prophet';
            prophetItem.innerHTML = `
                <div class="value">${comparison.prophet_metrics.accuracy.toFixed(1)}%</div>
                <div class="label">Prophet Accuracy</div>
            `;
            grid.appendChild(prophetItem);
            
            // Baseline metrics
            const baselineItem = document.createElement('div');
            baselineItem.className = 'comparison-item baseline';
            baselineItem.innerHTML = `
                <div class="value">${comparison.baseline_metrics.accuracy.toFixed(1)}%</div>
                <div class="label">Baseline Accuracy<br><small>("Same Week Last Year")</small></div>
            `;
            grid.appendChild(baselineItem);
            
            // Improvement
            const improvementItem = document.createElement('div');
            improvementItem.className = 'comparison-item improvement';
            const improvement = comparison.accuracy_improvement;
            const improvementSign = improvement >= 0 ? '+' : '';
            improvementItem.innerHTML = `
                <div class="value">${improvementSign}${improvement.toFixed(1)}%</div>
                <div class="label">Accuracy Improvement</div>
            `;
            grid.appendChild(improvementItem);
            
            // MAE comparison
            const maeItem = document.createElement('div');
            maeItem.className = 'comparison-item';
            const maeImprovement = comparison.mae_improvement;
            const maeSign = maeImprovement >= 0 ? '+' : '';
            maeItem.innerHTML = `
                <div class="value">${maeSign}${maeImprovement.toFixed(1)}%</div>
                <div class="label">MAE Improvement</div>
            `;
            grid.appendChild(maeItem);
            
            // Evaluation period
            const periodItem = document.createElement('div');
            periodItem.className = 'comparison-item';
            periodItem.innerHTML = `
                <div class="value">${comparison.eval_period}</div>
                <div class="label">Evaluation Period</div>
            `;
            grid.appendChild(periodItem);
            
            section.style.display = 'block';
        }

        function updateDashboard() {
            if (!currentForecast) return;
            
            // Update metric cards
            if (currentMetrics && currentMetrics.accuracy != null) {
                document.getElementById('modelAccuracy').textContent = currentMetrics.accuracy.toFixed(1) + '%';
            } else {
                document.getElementById('modelAccuracy').textContent = 'N/A';
            }
            
            const avgDemand = Math.round(currentForecast.predicted.reduce((a, b) => a + b, 0) / currentForecast.predicted.length);
            const totalForecast = currentForecast.predicted.reduce((a, b) => a + b, 0);
            const confidenceLevel = document.getElementById('confidence').value;
            const forecastWeeks = currentForecast.weeks.length;
            
            document.getElementById('avgDemand').textContent = avgDemand.toLocaleString();
            document.getElementById('totalForecast').textContent = totalForecast.toLocaleString();
            document.getElementById('confidenceLevel').textContent = confidenceLevel + '%';
            
            if (currentForecast.meal_id) {
                const cards = document.querySelectorAll('.metric-card p');
                if (cards.length >= 4) {
                    cards[0].textContent = `Prophet Accuracy`;
                    cards[1].textContent = `Avg Weekly Demand`;
                    cards[2].textContent = `Total Forecast`;
                    cards[3].textContent = `Confidence Level`;
                }
            }
            
            // Add business summary for short forecasts
            if (forecastWeeks <= 3) {
                addBusinessSummary();
            } else {
                removeBusinessSummary();
            }
            
            document.getElementById('metricsContainer').style.display = 'grid';
            
            // Update charts
            try {
                updateForecastChart();
                updatePerformanceChart();
                updateComparisonChart(); // Always show comparison chart
            } catch (error) {
                console.error('Error updating charts:', error);
                showError('Error updating charts', error.message);
            }
            
            showInsights(); 
            document.getElementById('insights').style.display = 'block';
        }

        function addBusinessSummary() {
            // Remove existing business summary if it exists
            removeBusinessSummary();
            
            const forecastWeeks = currentForecast.weeks.length;
            const mealId = currentForecast.meal_id || 'Unknown';
            const mealName = currentForecast.meal_name || `Meal ${mealId}`;
            const confidenceLevel = document.getElementById('confidence').value;
            
            // Create business summary section
            const businessSummary = document.createElement('div');
            businessSummary.id = 'businessSummary';
            businessSummary.className = 'business-summary';
            
            let summaryHTML = '';
            
            // For single week forecast - show simplified view
            if (forecastWeeks === 1) {
                const weekNum = 146; // Assuming last training week is 145
                const predicted = Math.round(currentForecast.predicted[0]);
                const upper = Math.round(currentForecast.upper[0]);
                const lower = Math.round(currentForecast.lower[0]);
                
                summaryHTML = `
                    <div class="business-grid-single">
                        <div class="business-single-week-card">
                            <h4 style="font-size: 1.1rem; margin-bottom: 25px; opacity: 0.9;">Week ${weekNum}</h4>
                            <div class="forecast-value" style="font-size: 3.5rem; margin-bottom: 15px;">${predicted.toLocaleString()}</div>
                            <div class="forecast-label" style="margin-bottom: 25px;">Predicted Orders</div>
                            <div class="confidence-range" style="font-size: 1.1rem;">
                                ${lower.toLocaleString()} - ${upper.toLocaleString()}
                                <br><small style="opacity: 0.8;">${confidenceLevel}% confidence interval</small>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // For multi-week forecasts, show the full detailed view
                summaryHTML = `
                    <h3>📋 Business Planning Summary - ${mealName}</h3>
                    <div class="business-grid">
                `;
                
                // Add forecast details for each week
                for (let i = 0; i < forecastWeeks; i++) {
                    const weekNum = 146 + i; // Assuming last training week is 145
                    const predicted = Math.round(currentForecast.predicted[i]);
                    const upper = Math.round(currentForecast.upper[i]);
                    const lower = Math.round(currentForecast.lower[i]);
                    
                    summaryHTML += `
                        <div class="business-week-card">
                            <h4>Week ${weekNum}</h4>
                            <div class="forecast-value">${predicted.toLocaleString()}</div>
                            <div class="forecast-label">Predicted Orders</div>
                            <div class="confidence-range">
                                Range: ${lower.toLocaleString()} - ${upper.toLocaleString()}
                                <br><small>${confidenceLevel}% confident</small>
                            </div>
                            <div class="business-actions">
                                <div class="action-item">
                                    <strong>Ingredients:</strong> ${Math.ceil(predicted * 1.1).toLocaleString()} portions
                                </div>
                                <div class="action-item">
                                    <strong>Staff:</strong> ${Math.ceil(predicted / 50)} prep hours
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                // Add total summary
                const totalPredicted = currentForecast.predicted.reduce((a, b) => a + b, 0);
                const totalUpper = currentForecast.upper.reduce((a, b) => a + b, 0);
                const totalLower = currentForecast.lower.reduce((a, b) => a + b, 0);
                
                summaryHTML += `
                        <div class="business-total-card">
                            <h4>Total ${forecastWeeks} Weeks</h4>
                            <div class="forecast-value total">${Math.round(totalPredicted).toLocaleString()}</div>
                            <div class="forecast-label">Total Orders</div>
                            <div class="confidence-range">
                                Range: ${Math.round(totalLower).toLocaleString()} - ${Math.round(totalUpper).toLocaleString()}
                            </div>
                            <div class="business-actions">
                                <div class="action-item">
                                    <strong>Total Ingredients:</strong> ${Math.ceil(totalPredicted * 1.1).toLocaleString()} portions
                                </div>
                                <div class="action-item">
                                    <strong>Budget Impact:</strong> ~€${Math.round(totalPredicted * 15).toLocaleString()}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="business-recommendations">
                        <h4>📊 Key Recommendations:</h4>
                        <ul>
                            <li><strong>Order ingredients for ${Math.ceil(totalPredicted * 1.1).toLocaleString()} portions</strong> (10% safety buffer included)</li>
                            <li><strong>Schedule ${Math.ceil(totalPredicted / 50)} total prep hours</strong> across the forecast period</li>
                            <li><strong>Monitor daily orders</strong> to adjust if trending toward upper/lower bounds</li>
                            <li><strong>Consider Prophet model</strong> for cost optimization - analyze with business cost feature</li>
                        </ul>
                    </div>
                `;
            }
            
            businessSummary.innerHTML = summaryHTML;
            
            // Insert before the charts section
            const chartsSection = document.querySelector('.charts');
            chartsSection.parentNode.insertBefore(businessSummary, chartsSection);
        }

        function removeBusinessSummary() {
            const existingSummary = document.getElementById('businessSummary');
            if (existingSummary) {
                existingSummary.remove();
            }
        }

        function updateForecastChart() {
            const ctx = document.getElementById('forecastChart');
            if (!ctx) return;
            
            const chartContext = ctx.getContext('2d');
            if (forecastChart) {
                forecastChart.destroy();
                forecastChart = null;
            }

            const confidenceLevel = document.getElementById('confidence').value;
            const forecastWeeks = currentForecast.weeks.length;
            const mealId = currentForecast.meal_id || 'Unknown';
            
            // Get meal name from the current forecast or metrics
            let mealName = 'Unknown Meal';
            if (currentForecast.meal_name) {
                mealName = currentForecast.meal_name;
            } else if (currentMetrics && currentMetrics.meal_name) {
                mealName = currentMetrics.meal_name;
            } else if (mealId !== 'Unknown') {
                const mealSelect = document.getElementById('mealSelect');
                const selectedOption = Array.from(mealSelect.options).find(opt => opt.value == mealId);
                if (selectedOption) {
                    mealName = selectedOption.textContent.split(' (ID:')[0];
                } else {
                    mealName = `Meal ${mealId}`;
                }
            }
            
            const lastTrainWeek = 145;
            
            // Enhanced visualization for short forecasts (1-3 weeks)
            let labels, datasets, chartTitle, xAxisTitle;
            
            if (forecastWeeks <= 3) {
                // For short forecasts, show historical context + forecast
                const historicalWeeks = Math.min(8, forecastWeeks * 4);
                
                // Create extended labels showing recent history + forecast
                const historicalLabels = [];
                const forecastLabels = [];
                
                for (let i = historicalWeeks; i >= 1; i--) {
                    historicalLabels.push(`Week ${lastTrainWeek - i + 1}`);
                }
                for (let i = 1; i <= forecastWeeks; i++) {
                    forecastLabels.push(`Week ${lastTrainWeek + i}`);
                }
                
                labels = [...historicalLabels, ...forecastLabels];
                
                // Get historical data if available from training performance
                let historicalData = new Array(historicalWeeks).fill(null);
                if (currentTrainingPerformance && currentTrainingPerformance.actual) {
                    const recentActual = currentTrainingPerformance.actual.slice(-historicalWeeks);
                    historicalData = recentActual.concat(new Array(Math.max(0, historicalWeeks - recentActual.length)).fill(null));
                }
                
                // Create seamless datasets
                const cleanHistoricalData = historicalData.map(val => val === null ? 0 : val);
                const seamlessData = [...cleanHistoricalData, ...currentForecast.predicted];
                
                // Confidence intervals only for forecast data
                const seamlessUpper = [...new Array(historicalWeeks).fill(null), ...currentForecast.upper];
                const seamlessLower = [...new Array(historicalWeeks).fill(null), ...currentForecast.lower];
                
                // Create point styles for emphasizing forecast points
                const pointRadii = new Array(historicalWeeks).fill(4).concat(new Array(forecastWeeks).fill(8));
                const pointColors = new Array(historicalWeeks).fill('#94a3b8').concat(new Array(forecastWeeks).fill('#667eea'));
                const pointBorderWidths = new Array(historicalWeeks).fill(1).concat(new Array(forecastWeeks).fill(3));
                
                datasets = [{
                    label: `${mealName} Orders (Historical + Forecast)`,
                    data: seamlessData,
                    borderColor: '#667eea',
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    fill: false,
                    tension: 0.3,
                    pointRadius: pointRadii,
                    pointBackgroundColor: pointColors,
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: pointBorderWidths,
                    borderWidth: 3,
                    segment: {
                        borderColor: ctx => {
                            if (ctx.p1DataIndex >= historicalWeeks) return '#667eea';
                            return '#94a3b8';
                        },
                        borderDash: ctx => {
                            if (ctx.p1DataIndex >= historicalWeeks) return [5, 5];
                            return [];
                        }
                    }
                }, {
                    label: `Upper Bound (${confidenceLevel}%)`,
                    data: seamlessUpper,
                    borderColor: 'rgba(255, 107, 107, 0.6)',
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    fill: '+1',
                    tension: 0.3,
                    pointRadius: ctx => ctx.dataIndex >= historicalWeeks ? 6 : 0,
                    pointStyle: 'triangle',
                    borderWidth: 2,
                    spanGaps: false,
                    segment: {
                        borderDash: ctx => ctx.p1DataIndex >= historicalWeeks ? [3, 3] : undefined
                    }
                }, {
                    label: `Lower Bound (${confidenceLevel}%)`,
                    data: seamlessLower,
                    borderColor: 'rgba(255, 107, 107, 0.6)',
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    fill: false,
                    tension: 0.3,
                    pointRadius: ctx => ctx.dataIndex >= historicalWeeks ? 6 : 0,
                    pointStyle: 'triangle',
                    borderWidth: 2,
                    spanGaps: false,
                    segment: {
                        borderDash: ctx => ctx.p1DataIndex >= historicalWeeks ? [3, 3] : undefined
                    }
                }];
                
                chartTitle = `${mealName}: Next ${forecastWeeks} Week${forecastWeeks > 1 ? 's' : ''} Forecast with Recent Context`;
                xAxisTitle = `Recent History → Future Forecast (${confidenceLevel}% CI)`;
                
            } else {
                // For longer forecasts, use original visualization
                labels = currentForecast.weeks.map(w => `Week ${lastTrainWeek + w}`);
                
                datasets = [{
                    label: `${mealName} Forecast`, 
                    data: currentForecast.predicted,
                    borderColor: '#667eea', 
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    fill: false, 
                    tension: 0.4, 
                    pointRadius: 4, 
                    pointHoverRadius: 6
                }, {
                    label: `Upper Bound (${confidenceLevel}%)`, 
                    data: currentForecast.upper,
                    borderColor: 'rgba(255, 107, 107, 0.5)', 
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    fill: '+1', 
                    tension: 0.4, 
                    pointRadius: 0
                }, {
                    label: `Lower Bound (${confidenceLevel}%)`, 
                    data: currentForecast.lower,
                    borderColor: 'rgba(255, 107, 107, 0.5)', 
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    fill: false, 
                    tension: 0.4, 
                    pointRadius: 0
                }, {
                    label: 'Trend Component', 
                    data: currentForecast.trend,
                    borderColor: '#4ECDC4', 
                    backgroundColor: 'rgba(78, 205, 196, 0.1)',
                    fill: false, 
                    tension: 0.4, 
                    borderDash: [5, 5], 
                    pointRadius: 2
                }];
                
                chartTitle = `${mealName}: Weeks ${lastTrainWeek + 1} to ${lastTrainWeek + forecastWeeks} (${confidenceLevel}% CI)`;
                xAxisTitle = `Forecasting ${forecastWeeks} Week${forecastWeeks > 1 ? 's' : ''} Ahead`;
            }

            try {
                const chartOptions = {
                    responsive: true, 
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    scales: {
                        y: { 
                            beginAtZero: true, 
                            title: { 
                                display: true, 
                                text: 'Meal Orders',
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' },
                            ticks: {
                                font: { size: 12 },
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        },
                        x: { 
                            title: { 
                                display: true, 
                                text: xAxisTitle,
                                font: { size: 14, weight: 'bold' }
                            },
                            grid: { color: 'rgba(0,0,0,0.1)' },
                            ticks: {
                                font: { size: 12 },
                                maxRotation: 45
                            }
                        }
                    },
                    plugins: {
                        title: { 
                            display: true, 
                            text: chartTitle,
                            font: { size: 16, weight: 'bold' },
                            padding: 20
                        },
                        legend: { 
                            display: true, 
                            position: 'top',
                            labels: {
                                font: { size: 12 },
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleFont: { size: 14, weight: 'bold' },
                            bodyFont: { size: 12 },
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toLocaleString() + ' orders';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    animation: {
                        duration: 1500,
                        easing: 'easeInOutQuart'
                    }
                };
                
                forecastChart = new Chart(chartContext, {
                    type: 'line',
                    data: { labels, datasets },
                    options: chartOptions
                });
                
            } catch (error) {
                console.error('Error creating forecast chart:', error);
                throw error;
            }
        }

        function updatePerformanceChart() {
            const ctx = document.getElementById('performanceChart');
            if (!ctx) return;
            
            const chartContext = ctx.getContext('2d');
            if (performanceChart) {
                performanceChart.destroy();
                performanceChart = null;
            }

            if (!currentMetrics) return;

            const forecastWeeks = currentForecast.weeks.length;
            
            const forecastMetrics = [
                'Model Training Accuracy',
                'Forecast Confidence', 
                'Data Coverage',
                'Trend Strength'
            ];
            
            const forecastValues = [
                currentMetrics.accuracy || 0,
                parseInt(document.getElementById('confidence').value),
                Math.min(100, (currentMetrics.test_samples || 0) * 3),
                Math.max(0, 100 - (currentMetrics.mape || 0))
            ];

            try {
                performanceChart = new Chart(chartContext, {
                    type: 'radar', 
                    data: {
                        labels: forecastMetrics, 
                        datasets: [{
                            label: `${forecastWeeks} Week Forecast Quality`,
                            data: forecastValues,
                            borderColor: '#667eea', 
                            backgroundColor: 'rgba(102, 126, 234, 0.2)',
                            pointBackgroundColor: '#667eea', 
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff', 
                            pointHoverBorderColor: '#667eea'
                        }]
                    }, 
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { 
                            r: { 
                                beginAtZero: true, 
                                max: 100, 
                                title: { display: true, text: 'Quality Score (%)' } 
                            } 
                        },
                        plugins: {
                            title: { display: true, text: `Forecast Quality Assessment` },
                            legend: { display: true, position: 'top' }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Error creating performance chart:', error);
                throw error;
            }
        }

        function updateComparisonChart() {
            const ctx = document.getElementById('accuracyChart');
            if (!ctx) return;
            
            const chartContext = ctx.getContext('2d');
            if (accuracyChart) {
                accuracyChart.destroy();
                accuracyChart = null;
            }

            // Show comparison chart if available, otherwise show training performance
            if (currentComparison) {
                const mealId = currentComparison.meal_id || 'Unknown';
                const regionId = currentComparison.region_id;
                const prophetImprovement = currentComparison.accuracy_improvement;
                const maeImprovement = currentComparison.mae_improvement;
                
                // Update the chart title
                const titleElement = document.getElementById('trainingPerformanceTitle');
                if (titleElement) {
                    const regionText = regionId ? ` (${regionId})` : ' (All Regions)';
                    titleElement.textContent = `🥊 Prophet vs Baseline Comparison - Meal ${mealId}${regionText}`;
                }

                try {
                    const datasets = [
                        {
                            label: `Actual Meal ${mealId} Orders`,
                            data: currentComparison.actual,
                            borderColor: '#4ECDC4',
                            backgroundColor: 'rgba(78, 205, 196, 0.05)',
                            fill: false,
                            tension: 0.2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            pointStyle: 'circle',
                            borderWidth: 2
                        },
                        {
                            label: `Prophet (${currentComparison.prophet_metrics.accuracy.toFixed(1)}% accuracy)`,
                            data: currentComparison.prophet_predicted,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.05)',
                            fill: false,
                            tension: 0.2,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            borderDash: [4, 4],
                            borderWidth: 1.5
                        },
                        {
                            label: `Baseline (${currentComparison.baseline_metrics.accuracy.toFixed(1)}% accuracy)`,
                            data: currentComparison.baseline_predicted,
                            borderColor: '#FF6B6B',
                            backgroundColor: 'rgba(255, 107, 107, 0.05)',
                            fill: false,
                            tension: 0.2,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            borderDash: [8, 4],
                            borderWidth: 1.5
                        }
                    ];

                    accuracyChart = new Chart(chartContext, {
                        type: 'line',
                        data: {
                            labels: currentComparison.weeks,
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: { intersect: false, mode: 'index' },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: { 
                                        display: true, 
                                        text: `Orders`,
                                        font: { size: 12, weight: 'bold' }
                                    },
                                    grid: { color: 'rgba(0,0,0,0.08)' },
                                    ticks: {
                                        font: { size: 11 },
                                        callback: function(value) {
                                            return value.toLocaleString();
                                        }
                                    }
                                },
                                x: {
                                    title: { 
                                        display: true, 
                                        text: `Evaluation Period | Prophet: +${prophetImprovement.toFixed(1)}% accuracy improvement`,
                                        font: { size: 11, weight: 'bold' }
                                    },
                                    grid: { color: 'rgba(0,0,0,0.08)' },
                                    ticks: { 
                                        font: { size: 10 },
                                        maxRotation: 45
                                    }
                                }
                            },
                            plugins: {
                                title: { 
                                    display: true, 
                                    text: `Model Comparison: Prophet vs Baseline`,
                                    font: { size: 14, weight: 'bold' },
                                    padding: 15
                                },
                                legend: { 
                                    display: true, 
                                    position: 'top',
                                    labels: {
                                        font: { size: 10 },
                                        usePointStyle: true,
                                        padding: 12,
                                        boxWidth: 12
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    backgroundColor: 'rgba(0,0,0,0.85)',
                                    titleFont: { size: 12, weight: 'bold' },
                                    bodyFont: { size: 11 },
                                    cornerRadius: 6,
                                    callbacks: {
                                        label: function(context) {
                                            let label = context.dataset.label || '';
                                            if (label) label += ': ';
                                            if (context.parsed.y !== null) {
                                                label += context.parsed.y.toLocaleString() + ' orders';
                                            }
                                            return label;
                                        },
                                        afterBody: function(tooltipItems) {
                                            const weekIndex = tooltipItems[0].dataIndex;
                                            const actual = currentComparison.actual[weekIndex];
                                            const prophet = currentComparison.prophet_predicted[weekIndex];
                                            const baseline = currentComparison.baseline_predicted[weekIndex];
                                            
                                            const prophetError = Math.abs(actual - prophet);
                                            const baselineError = Math.abs(actual - baseline);
                                            const difference = baselineError - prophetError;
                                            
                                            return [
                                                '',
                                                `Prophet Error: ${prophetError.toLocaleString()}`,
                                                `Baseline Error: ${baselineError.toLocaleString()}`,
                                                difference > 0 ? 
                                                    `✅ Prophet better by ${difference.toLocaleString()}` :
                                                    `❌ Baseline better by ${Math.abs(difference).toLocaleString()}`
                                            ];
                                        }
                                    }
                                }
                            },
                            elements: {
                                point: {
                                    hoverRadius: 6
                                },
                                line: {
                                    cubicInterpolationMode: 'monotone'
                                }
                            },
                            animation: {
                                duration: 1000,
                                easing: 'easeInOutQuart'
                            }
                        }
                    });
                    
                } catch (error) {
                    console.error('Error creating comparison chart:', error);
                    throw error;
                }
                
            } else if (currentTrainingPerformance) {
                // Show training performance if no comparison available
                const labels = currentTrainingPerformance.weeks;
                const actualData = currentTrainingPerformance.actual;
                const predictedData = currentTrainingPerformance.predicted;
                const mealId = currentForecast?.meal_id || currentMetrics?.meal_id || 'Unknown';
                const regionId = currentMetrics?.region_id;
                
                const titleElement = document.getElementById('trainingPerformanceTitle');
                if (currentTrainingPerformance.week_range && currentTrainingPerformance.total_weeks_available) {
                    const regionText = regionId ? ` (${regionId})` : ' (All Regions)';
                    titleElement.textContent = `🎯 Meal ${mealId} Training Performance${regionText}`;
                }

                try {
                    accuracyChart = new Chart(chartContext, {
                        type: 'line', 
                        data: {
                            labels: labels, 
                            datasets: [{
                                label: `Actual Meal ${mealId} Orders`, 
                                data: actualData,
                                borderColor: '#4ECDC4', 
                                backgroundColor: 'rgba(78, 205, 196, 0.1)',
                                fill: false, 
                                tension: 0.4,
                                pointRadius: 4
                            }, {
                                label: `Prophet Predictions for Meal ${mealId}`, 
                                data: predictedData,
                                borderColor: '#667eea', 
                                backgroundColor: 'rgba(102, 126, 234, 0.1)',
                                fill: false, 
                                tension: 0.4,
                                pointRadius: 4,
                                borderDash: [5, 5]
                            }]
                        }, 
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: { intersect: false, mode: 'index' },
                            scales: { 
                                y: { 
                                    beginAtZero: true, 
                                    title: { display: true, text: `Meal ${mealId} Orders` } 
                                },
                                x: { 
                                    title: { 
                                        display: true, 
                                        text: `Training Validation Period` 
                                    } 
                                }
                            },
                            plugins: {
                                title: { 
                                    display: true, 
                                    text: `Meal ${mealId} Training Performance` 
                                },
                                legend: { display: true, position: 'top' }
                            }
                        }
                    });
                    
                } catch (error) {
                    console.error('Error creating training performance chart:', error);
                    throw error;
                }
                
            } else {
                // Show placeholder
                try {
                    accuracyChart = new Chart(chartContext, {
                        type: 'bar', 
                        data: {
                            labels: ['No Data'], 
                            datasets: [{
                                label: 'No comparison or training data available', 
                                data: [0],
                                backgroundColor: 'rgba(200, 200, 200, 0.5)'
                            }]
                        }, 
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: { 
                                    display: true, 
                                    text: 'Comparison Data Not Available' 
                                }
                            }
                        }
                    });
                    
                } catch (error) {
                    console.error('Error creating placeholder chart:', error);
                    throw error;
                }
            }
        }

        function showInsights() {
            const insights = [];
            const mealId = currentForecast?.meal_id || 'Unknown';
            
            if (currentMetrics) {
                if (currentMetrics.accuracy > 90) {
                    insights.push(`🎯 Excellent performance for Meal ${mealId} - Prophet is highly accurate (${currentMetrics.accuracy.toFixed(1)}%)`);
                } else if (currentMetrics.accuracy > 80) {
                    insights.push(`✅ Good performance for Meal ${mealId} - Prophet provides reliable forecasts (${currentMetrics.accuracy.toFixed(1)}%)`);
                } else if (currentMetrics.accuracy > 70) {
                    insights.push(`⚠️ Moderate performance for Meal ${mealId} - consider adjustments (${currentMetrics.accuracy.toFixed(1)}%)`);
                } else {
                    insights.push(`❌ Lower accuracy for Meal ${mealId} - may need different approach (${currentMetrics.accuracy.toFixed(1)}%)`);
                }
            }
            
            // Add comparison insights if available
            if (currentComparison) {
                const prophetAcc = currentComparison.prophet_metrics.accuracy;
                const baselineAcc = currentComparison.baseline_metrics.accuracy;
                const improvement = currentComparison.accuracy_improvement;
                
                if (improvement > 5) {
                    insights.push(`✅ Prophet significantly outperforms naive baseline (+${improvement.toFixed(1)}% accuracy improvement)`);
                    insights.push(`📈 Prophet: ${prophetAcc.toFixed(1)}% vs Baseline: ${baselineAcc.toFixed(1)}% - Clear advantage to advanced modeling`);
                } else if (improvement > 0) {
                    insights.push(`✅ Prophet modestly outperforms baseline (+${improvement.toFixed(1)}% accuracy improvement)`);
                } else {
                    insights.push(`⚠️ Prophet performs similarly to naive baseline - consider feature engineering or data quality`);
                }
                
                insights.push(`🎯 Baseline uses "same week last year" - Prophet learns complex patterns and seasonality`);
            }
            
            // Add business cost insights if available
            if (currentBusinessCost) {
                const savings = currentBusinessCost.cost_savings_euro;
                const weeklySavings = currentBusinessCost.avg_weekly_savings_euro;
                const annualSavings = currentBusinessCost.annual_savings_estimate_euro;
                
                if (savings > 0) {
                    insights.push(`💰 Prophet saves €${savings.toFixed(2)} vs baseline over ${currentBusinessCost.weeks_analyzed} test weeks`);
                    insights.push(`📅 Weekly benefit: €${weeklySavings.toFixed(2)} saved per week compared to naive forecasting`);
                    insights.push(`📈 Annual impact: €${annualSavings.toLocaleString()} saved by avoiding baseline's poor predictions`);
                    insights.push(`🎯 Clear financial advantage: Prophet significantly outperforms "same week last year" approach`);
                } else {
                    insights.push(`❌ Prophet costs €${Math.abs(savings).toFixed(2)} more than baseline - model needs improvement`);
                    insights.push(`📉 Weekly impact: €${Math.abs(weeklySavings).toFixed(2)} additional cost per week vs simple baseline`);
                    insights.push(`⚠️ Recommendation: Baseline "same week last year" method performs better financially`);
                }
                
                insights.push(`🍽️ Analysis includes real food waste costs and emergency procurement penalties`);
            }
            
            if (currentForecast) {
                const avgForecast = currentForecast.predicted.reduce((a, b) => a + b, 0) / currentForecast.predicted.length;
                const totalForecast = currentForecast.predicted.reduce((a, b) => a + b, 0);
                insights.push(`📦 Expected weekly demand for Meal ${mealId}: ${Math.round(avgForecast).toLocaleString()} orders`);
                insights.push(`🎯 Total ${currentForecast.weeks.length}-week forecast: ${totalForecast.toLocaleString()} orders`);
            }
            
            insights.push(`🍽️ Use forecasts for ingredient procurement and supply chain planning`);
            insights.push(`📅 Meal-specific seasonality patterns optimize kitchen preparation schedules`);
            insights.push(`🔄 Retrain models weekly with new sales data for optimal accuracy`);
            
            if (currentMetrics && currentMetrics.accuracy > 85) {
                insights.push(`💰 High accuracy enables just-in-time ingredient ordering and cost reduction`);
                insights.push(`📈 Consider using forecasts for pricing optimization and demand shaping`);
            }

            document.getElementById('insightsList').innerHTML = insights.map(insight => `<li>${insight}</li>`).join('');
        }

        function showLoading(show) { 
            document.getElementById('loadingSection').style.display = show ? 'block' : 'none'; 
        }
        
        function disableButtons(disable) {
            document.getElementById('mainActionBtn').disabled = disable;
        }

        function showStatusMessage(message, type) {
            const statusSection = document.getElementById('statusSection');
            const statusMessage = document.getElementById('statusMessage');
            
            // Clean up the message
            let cleanMessage = message;
            cleanMessage = cleanMessage.replace(/❌\s*❌/g, '❌');
            
            // Format region lists nicely
            if (cleanMessage.includes('[') && cleanMessage.includes(']')) {
                cleanMessage = cleanMessage.replace(/\[([^\]]+)\]/g, (match, regions) => {
                    const regionList = regions.split(',').map(r => r.trim().replace(/['"]/g, ''));
                    
                    if (regionList.length === 1) {
                        return regionList[0];
                    } else if (regionList.length === 2) {
                        return regionList.join(' and ');
                    } else {
                        const lastRegion = regionList.pop();
                        return regionList.join(', ') + ', and ' + lastRegion;
                    }
                });
            }
            
            cleanMessage = cleanMessage.replace(/This meal is available in:/g, 'Available regions:');
            cleanMessage = cleanMessage.replace(/Available meals:/g, 'Try these meals instead:');
            
            statusMessage.innerHTML = cleanMessage;
            
            if (type === 'success') {
                statusSection.style.background = 'linear-gradient(135deg, #4ECDC4, #44A08D)';
            } else if (type === 'error') {
                statusSection.style.background = 'linear-gradient(135deg, #FF6B6B, #FF5722)';
            } else {
                statusSection.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
            }
            
            setTimeout(() => {
                statusSection.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
            }, 5000);
        }

        function formatErrorMessage(message) {
            let formatted = message;
            
            // Remove duplicate error icons
            formatted = formatted.replace(/❌\s*❌/g, '❌');
            
            // Format lists nicely
            if (formatted.includes('[') && formatted.includes(']')) {
                formatted = formatted.replace(/\[([^\]]+)\]/g, (match, content) => {
                    const items = content.split(',').map(item => item.trim().replace(/['"]/g, ''));
                    
                    if (items.length === 1) {
                        return items[0];
                    } else if (items.length === 2) {
                        return items.join(' and ');
                    } else {
                        const last = items.pop();
                        return items.join(', ') + ', and ' + last;
                    }
                });
            }
            
            return formatted;
        }

        // Chart.js error handling
        Chart.defaults.plugins.legend.display = true;
        Chart.defaults.responsive = true;
        Chart.defaults.maintainAspectRatio = false;

        // Add global error handler for uncaught errors
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.message);
            showError('Unexpected error occurred', event.message);
        });

        // Add unhandled promise rejection handler
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            showError('Promise rejection', event.reason.toString());
        });
    </script>
</body>
</html>